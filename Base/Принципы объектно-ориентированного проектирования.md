
# Основные принципы

- Инкапсулируйте то, что меняется
- Уделяйте больше внимания интерфейсам, а не их реализациям
- Каждый класс в вашем приложении должен иметь только одну причину для изменения
- Классы - это поведение и функциональность

---

# Основные термины

## Абстракция

Процесс отделения идей от конкретных экземпляров этих идей.

## Полиморфизм

Предоставление единого интерфейса для сущностей разного типа. Подтипирование.

## Наследование

Способность объекта или класса базироваться на другом объекте или классе. Это главный механизм для повторного использования кода. Наследованное отношение классов четко определяет их иерархию.

## Инкапсуляция

Заключение объектов в общий интерфейс, что делает их взаимозаменяемыми, защищает их состояния от недопустимых изменений.

---

# Используйте следующее вместе с наследованием

## Делегация

Передача ответственности за какую-либо задачу другому классу или методу.

## Композиция

Включение объектом-контейнером объекта-содержимого и управление его поведением. Последний не может существовать вне первого.

## Агрегация

Использование одного класса как часть другого класса, при этом используемый класс существует вне использующего класса.

---

# Don't Repeat Yourself (DRY)

Избегайте повторного написания кода, вынося в абстракции часто используемые задачи и данные. Каждая часть вашего кода или информации должна находиться в единственном числе в единственном доступном месте.

---

# SOLID

## Single Responsibility Principle

Или **Принцип единственной обязанности**. Для каждого класса должно быть определено единственное назначение. Все ресурсы, необходимые для его осуществления, должны быть инкапсулированы в этот класс и подчинены только этой задаче.

## Open-Closed Principle

Или **Принцип открытости/закрытости**. Программные сущности должны быть *открыты* для расширения, но *закрыты* для изменения.

## Liskov Substitution Principle

Или **Принцип подстановки Лисков**. Методы, использующие некий тип, должны иметь возможность использовать его подтипы, не зная об этом.

## Interface Segregation Principle

Или **Принцип разделения интерфейсов**. Предпочтительнее разделять интерфейсы на более мелкие, тематические, чтобы реализующие их классы не были вынуждены определять методы, которые непосредственно в них не используются.

## Dependency Inversion Principle

Или **Принцип инверсии зависимостей**. Система должна конструироваться на основе абстракций "сверху вниз": не абстракции должны формироваться на основе деталей, а детали должны формироваться на основе абстракций.
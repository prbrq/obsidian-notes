
Делегат - это объект, который содержит указатель на метод, что позволяет передавать метод как аргумент другим методам.

Видео с объяснениями (тг 20.01.2023, там же можно взять код для примера).

```cs
namespace DelegateProject
{
    public delegate void TellUser(string input);
    class Program
    {
        static void Main(string[] args)
        {
            Run(Console.WriteLine);
            Run(TellUpperCase);
        }

        static void Run(TellUser tellUser)
        {
            tellUser("hi!");
            tellUser("how r u?");
        }

        static void TellUpperCase(string input)
        {
            Console.WriteLine(input.ToUpper());
        }
    }
}
```

---

Проще всего использовать уже готовые [[Лямбда-выражения|универсальные делегаты]], а не объявлять свои.

Делегат это тип данных, поэтому он определяется на одном уровне с `class` и `struct`.

Делегат представляет из себя два указателя. Первый указатель это **Method**, он указывает на метод, который нужно вызвать. Второй - это **Target**. Для динамических методов он указывает на объект, из контекста которого нужно вызвать **Method**, а для статических методов он равен `null`.

Для упрощения использования делегатов существует два вида синтаксического сахара, это [[Func|Func<>]] и [[Action|Action<>]].

В переменную делегатного типа можно положить существующий метод, либо написать лямбду.
```cs
Action<string> a1 = Console.WriteLine;
Action<string> a2 = str => Console.WriteLine(str);
```

Лямбда имеет доступ к локальным переменным метода, в котором объявлена. Это называется **замыкание**.
```cs
var str = "Hello";
Action action = () => Console.WriteLine(str);
action(); // Напечатает Hello
```

Делегат, хранящий ссылку на метод, - это обычный тип данных. Получается, метод можно передавать как аргумент в метод, возвращать из метода, класть в словарь по ключу и всё остальное.

Имея такие широкие возможности по манипуляции методами, С# поддерживает функциональный стиль программирования.

##### Еще один пример использования делегата

Таймер, который раз в 1000 миллисекунд будет вызывать переданный в него метод.

```cs
using System;
using System.Threading;

public class Timer
{
    public int Interval;
    public Action Tick;

    public void Start()
    {
        while(true)
        {
            if(Tick != null) // если в Tick ничего не присвоить и вызвать, будет NullReferenceException
                Tick();
            Thread.Sleep(Interval); // ждет заданное время
        }
    }
}

public class Program
{
    public static void Main()
    {
        var timer = new Timer();
        timer.Interval = 1000;
        timer.Tick = () => Console.WriteLine("Tick!");
        timer.Start();
    }
}
```

---

# Мультикаст-делегаты

Делегаты могут хранить сразу несколько методов. Это называется мультикаст-делегат. Методы добавляются с помощью оператора `+=`. Удалить метод можно с помощью `-=`.

```cs
Action<int> action = null;
action += (x) => Console.Write(x + 2 + " ");
action += (x) => Console.Write(x * 2 + " ");
action(3); // OUTPUT: 5 6 
```

Мультикаст-делегат - это список делегатов одинакового типа. В отладчике этот список называется `_invocationList`. При вызове мультикаст-делегата по очереди вызываются содержащиеся в нем делегаты.

```cs
Func<int, int> f = null;
f += x => 2 * x;
f += x => 3 * x;
Console.WriteLine(f(3)); // OUTPUT: 9
```

Здесь будут вызваны обе функции по порядку. Каждой будет передан аргумент 3. Результатом выполнения будет значение, которое вернула последняя функция.

---

# Cсылки

- [[Классы и объекты]];
- [[Методы]];
- [[Struct]];
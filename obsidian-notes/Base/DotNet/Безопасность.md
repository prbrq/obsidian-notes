
## Терминология безопасности

Существует множество способов защиты данных; шесть самых популярных из них перечислены ниже.

- *Шифрование и дешифрование* — двухсторонний процесс преобразования читаемого текста в шифрованный и обратно.
- *Хеши* — односторонний процесс генерации хеш-значения для безопасного хранения паролей или обнаружения вредоносных изменений либо повреждений данных.
- *Цифровые подписи* — метод проверки источника поступивших данных путем верификации цифровой подписи данных с помощью открытого ключа.
- *Аутентификация* — метод идентификации пользователя путем проверки его учетных данных.
- *Авторизация* — метод выдачи допуска на выполнение неких действий или работы с определенными данными путем проверки ролей или групп, к которым принадлежат пользователи.

Пример отличия Аутентификации от Авторизации из книги Марка Прайса: "Например, вместо того, чтобы назначать права доступа для нанесения ядерного удара Дональду Трампу (пользователю), вы назначаете права доступа для запуска ядерного удара президенту Соединенных Штатов (роль), а затем добавляете Дональда Трампа в качестве участника этой роли."

## Ключи и их размеры

В алгоритмах защиты часто используются ключи. Они представлены байтовыми массивами различного размера.

Ключи могут быть симметричными (также известны как общие или секретные, поскольку один и тот же ключ используется для шифрования и дешифрования) и асимметричными (пара из открытого и закрытого ключей, в которых открытый используется для шифрования, а только закрытый — для дешифрования).

> [!Note]
> Алгоритмы шифрования с помощью симметричных ключей быстры и позволяют 
> шифровать большие объемы потоковых данных. Асимметричные алгоритмы шифрования ключей медленны и дают возможность шифровать только небольшие массивы байтов.

## Векторы инициализации и размеры блоков

Вполне вероятно, что при шифровании больших объемов данных повторяются некоторые из их фрагментов (последовательностей символов). Например, в английском тексте часто применяется последовательность символов the, которая каждый раз шифруется как hQ2. Умный хакер воспользовался бы этим и упростил бы себе работу по взлому шифра:

```
When the wind blew hard the umbrella broke.
5:s4&hQ2aj#D f9d1dЈ8fh"&hQ2s0)an DF8SFd#][1
```

Мы можем избежать повторения последовательностей, разделив данные на *блоки*. После шифрования блока из него генерируется значение массива байтов, которое передается в следующий блок с целью настройки алгоритма так, чтобы последовательность the шифровалась иначе. Зашифровать первый блок можно при наличии массива байтов для выполнения задачи. Это так называемый *вектор инициализации* (initialization vector, IV).

## Соли

*Соль* представляет собой случайный массив байтов, который используется как дополнительный ввод для односторонней хеш-функции. Если вы не применяете соль при генерации хешей, то при условии, что многие из ваших пользователей регистрируются, указывая 123456 в качестве пароля (по данным на 2016-й год, примерно 8 % пользователей так и делают!), все они имеют одно и то же хеш-значение и их учетная запись будет уязвима для внешнего доступа через подбор пароля по словарю.

Когда пользователь регистрируется, соль должна генерироваться случайным образом и конкатенироваться с указанным пользователем паролем до того, как будет хеширована. Результат этой операции (но не исходный пароль) сохраняется с солью в базе данных.

Когда пользователь авторизуется в системе и вводит пароль, вы просматриваете соль, объединяете ее с введенным паролем, восстанавливаете хеш и затем сравниваете значение с хешем, хранящимся в базе данных. Если значения совпадают, то пароль введен верно.
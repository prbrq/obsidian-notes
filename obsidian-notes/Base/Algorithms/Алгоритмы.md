
Алгоритмом называется набор инструкций для выполнения некоторой задачи.

---

# Бинарный поиск

На входе этот алгоритм получает отсортированный список элементов. Если элемент, который нужно найти, присутствует в списке, то бинарный поиск возвращает его позицию. В противном случае возвращает `null`.

В алгоритме бинарного поиска нужно каждый раз проверять среднее значение, а затем исключать половину оставшихся значений. 

С каждым шагом бинарного поиска количество возможных значений сокращается вдвое, пока не останется только одно слово. 

Таким образом, для поиска нужного значения в списке из 240 000 значений потребуется 18 шагов алгоритма бинарного поиска.

Максимальное количество шагов бинарного поиска равно $\log_{2}N$, где $N$ - это количество элементов. Например, для худшего случая поиска нужного значения в отсортированном массиве из 1024 элементов понадобится 10 шагов.

> [!Note]
> Бинарный поиск работает только в том случае, если список отсортирован 

```cs
static int? BinarySearch(int[] numbers, int item)
{
    var low = 0;
    var high = numbers.Length - 1;
    while (low <= high)
    {
        var mid = (low + high) / 2;
        var guess = numbers[mid];
        if (guess == item)
            return mid;
        if (guess > item)
            high = mid - 1;
        else
            low = mid + 1;
    }
    return null;
}
```

---

# Сортировка выбором

Самый простой и неэффективный алгоритм сортировки. Необходимо каждый раз находить минимальный или максимальный элемент, а затем повторять поиск не учитывая уже найденные элементы.

```cs
static List<int> SelectionSort(List<int> unsortedList)
{
    var sortedList = new List<int>();
    while (unsortedList.Count > 0)
    {
        var minValue = unsortedList.Min();
        var minIndex = unsortedList.IndexOf(minValue);
        sortedList.Add(minValue);
        unsortedList.RemoveAt(minIndex);
    }
    return sortedList;
}
```

---

# Быстрая сортировка

```cs
static void Main(string[] args)
{
    var arr = new int[] { 10, 5, 2, 3 };
    Console.WriteLine(string.Join(", ", QuickSort(arr)));
}

static IEnumerable<int> QuickSort(IEnumerable<int> list)
{
    if (list.Count() <= 1) return list;
    var pivot = list.First();
    var less = list.Skip(1).Where(number => number <= pivot);
    var greater = list.Skip(1).Where((number) => number > pivot);
    return QuickSort(less).Union(new List<int> { pivot }).Union(QuickSort(greater));
}
```

В худшем случае алгоритм сортировки работает за время $O(n^2)$, но в среднем за $O(n*logn)$.
На практике быстрая сортировка работает очень быстро, потому что средний случай встречается намного чаще худшего.

Это один из самых быстрых существующих алгоритмов сортировки, который заодно
является хорошим примером стратегии "разделяй и властвуй".

При реализации алгоритма быстрой сортировки следует выбирать случайный элемент в качестве опорного.

---

# Поиск в ширину

Алгоритм можно применять для невзвешенных графов. Он позволяет определить:
- Существует ли путь из A в B;
- Кратчайший путь из A в B, если путь между ними существует.

Более подробно в 6 главе книге "Грокаем алгоритмы".

---

# Алгоритм Дейкстры

В отличии от [[Алгоритмы#Поиск в ширину|поиска в ширину]], этот алгоритм позволяет определить путь из A в B во взвешенном графе.

Более подробно в 7 главе книге "Грокаем алгоритмы".

---

# Жадный алгоритм

Суть в том, что нужно отсортировать данные по критерию *привлекательности*. Затем брать самое *привлекательное*, затем самое *привлекательное*, которое совместимо с предыдущим *привлекательным*. [[Алгоритм планирования встреч|Здесь]] можно посмотреть пример.

Более подробно в 8 главе книги "Грокаем алгоритмы".

---

# Динамическое программирование

Динамическое программирование применяется при оптимизации некоторой характеристики. В каждом решении из области динамического программирования строится таблица. Каждая ячейка представляет подзадачу, поэтому необходимо подумать о том, как разбить задачу на автономные подзадачи.

Более подробно в 9 главе книги "Грокаем алгоритмы".

---

# k ближайших соседей

Алгоритм k ближайших соседей применяется для распределения по категориям и прогнозирований ответа. В нем используется проверка k ближайших соседей. Также на этом алгоритме строится машинное обучение.

Более подробно в 10 главе книги "Грокаем алгоритмы".